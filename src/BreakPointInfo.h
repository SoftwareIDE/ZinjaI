#ifndef BREAKPOINTINFO_H
#define BREAKPOINTINFO_H
#include <wx/string.h>
#include "AutoList.h"

class mxSource;
class file_item;

/**
* @brief guarda toda la información acerca de un punto de interrupción
*
* Saves all information related to a breakpoint: it's gdb status, all options 
* setted in mxBreakOptions, and its handler for the mxSource's marker. It also 
* has some pointers to make a list per file with them.
*
* Instances are property of file_item, but are shared with mxSource, and
* modified by DebugManager.
**/

enum BREAK_POINT_STATUS { 
	BPS_UNKNOWN=0, ///< dafault status, should never be this one while debug->debugging
	BPS_PENDING, ///< waiting for the debugger to pause to set this breakpoint
	BPS_ERROR_SETTING, ///< there was a problem trying to set the breakpoint in gdb
	BPS_GDB_KNOWS_IT, ///< states lower than this one are states for breakpoints not inserted into gdb, over this one has a valid gdb_id, no one should take this state
	BPS_SETTED, ///< normal status
	BPS_ERROR_CONDITION, ///< the condition is not valid
	BPS_USER_DISABLED, ///< when user marks the breakpoint as not enabled
	BPS_DISABLED_ONLY_ONCE, ///< when it's been hitted once and only_once=true
};

class BreakPointInfo {
	_autolist_declare_global(BreakPointInfo);
	_autolist_declare_local(BreakPointInfo);
public:
	static int last_zinjai_id;
	int zinjai_id; ///< id inside ZinjaI, autogenerated
	wxString fname; ///< filename's fullpath, for telling gdb
	int line_number; ///< line number, base 0
	int gdb_id; ///< id setted by gdb,  -1 if not setted, only valid while debug->debugging (gdb)
	BREAK_POINT_STATUS gdb_status; ///< status inside gdb (gdb)
	mxSource *source; ///< if the file is oppened, it's that mxSource, else it's NULL 
	int marker_handle; ///< marker handle if it's open (mxSource)
	int marker_type; ///< to know if current marker is red or grey, when marker_handle!=-1
	bool enabled; ///< if it's marked as enabled in ZinjaI (mxBreakOptions)
	bool only_once; ///< if this breakpoint should be disabled after been hitted for the first time (mxBreakOptions)
	int ignore_count; ///< number of times the breakpoint should be reached before really pausing the program (mxBreakOptions)
	wxString cond; ///< bool expression for conditional breakpoints (mxBreakOptions)
	BreakPointInfo(file_item *fitem, int _line_number); ///< to be called when loading a project, registers the breakpoint in the file_item::breaklist
	BreakPointInfo(mxSource *_source, int _line_number); ///< to be called from mxSource events, registers the breakpoint in the mxSource::breaklist
	void SetStatus(BREAK_POINT_STATUS _status, int _gdb_id=-1);
	void UpdateLineNumber();
	void SetSource(mxSource *_source);
	bool IsInGDB();
	void SetMarker();
	static BreakPointInfo *FindFromNumber(int _id, bool use_gdb_id);
	~BreakPointInfo();
};

#endif

