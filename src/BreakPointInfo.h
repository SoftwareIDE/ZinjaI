#ifndef BREAKPOINTINFO_H
#define BREAKPOINTINFO_H
#include <wx/string.h>
#include "SingleList.h"

class mxSource;
class project_file_item;

/**
* @brief guarda toda la información acerca de un punto de interrupción
*
* Saves all information related to a breakpoint: it's gdb status, all options 
* setted in mxBreakOptions, and its handler for the mxSource's marker. It also 
* has some pointers to make a list per file with them.
*
* Instances are property of file_item, but are shared with mxSource, and
* modified by DebugManager.
**/

enum BREAK_POINT_STATUS { 
	BPS_UNKNOWN=0, ///< default status, should never be this one while debug->debugging
	BPS_PENDING, ///< waiting for the debugger to pause to set this breakpoint
	BPS_ERROR_SETTING, ///< there was a problem trying to set the breakpoint in gdb
	BPS_GDB_KNOWS_IT, ///< states lower than this one are states for breakpoints not inserted into gdb, over this one has a valid gdb_id, no one should take this state
	BPS_SETTED, ///< normal status
	BPS_ERROR_CONDITION, ///< the condition is not valid
	BPS_USER_DISABLED, ///< when user marks the breakpoint as not enabled
	BPS_DISABLED_ONLY_ONCE, ///< when it's been hitted once and only_once=true
};

enum BREAK_POINT_ACTION {
	BPA_STOP_ALWAYS=0, ///< regular breakpoint, pauses execution everytime its hitted
	BPA_STOP_ONCE=1, ///< single time breakpoint, pauses execution only the first time its hitted
	BPA_INSPECTIONS=2 ///< fake breakpoint, updates the inspections table and continue the execution
};

class BreakPointInfo {
public:
	static GlobalList<BreakPointInfo*> global_list;
	static GlobalListIterator<BreakPointInfo*> GetGlobalIterator();
	static int last_zinjai_id;
	int zinjai_id; ///< id inside ZinjaI, autogenerated
	wxString fname; ///< filename's fullpath, for telling gdb
	int line_number; ///< line number, base 0
	int gdb_id; ///< id setted by gdb, -1 if not setted, only valid while debug->debugging (gdb)
	BREAK_POINT_STATUS gdb_status; ///< status inside gdb (gdb)
	mxSource *source; ///< if the file is oppened, it's that mxSource, else it's nullptr 
	int marker_handle; ///< marker handle if it's open (mxSource)
	int marker_type; ///< to know if current marker is red or grey, when marker_handle!=-1
	bool enabled; ///< if it's marked as enabled in ZinjaI (mxBreakOptions)
	int action; ///< what to do when breakpoint is hitted, valid values are from BREAK_POINT_ACTION
	int ignore_count; ///< number of times the breakpoint should be reached before really pausing the program (mxBreakOptions)
	wxString cond; ///< bool expression for conditional breakpoints (mxBreakOptions)
	wxString annotation; ///< some description or whatever the user can set and will be displayed when the bp is hitted
	BreakPointInfo(project_file_item *fitem, int _line_number); ///< to be called when loading a project, registers the breakpoint in the file_item::breaklist
	BreakPointInfo(mxSource *_source, int _line_number); ///< to be called from mxSource events, registers the breakpoint in the mxSource::breaklist
	void SetStatus(BREAK_POINT_STATUS _status, int _gdb_id=-1);
	void UpdateLineNumber();
	void SetSource(mxSource *_source);
	void SetEnabled(bool do_enable); ///< to be called from gui, sets the bp as enabled or disable (toggles) in gui and in its internal state (not in DebugManager, that should be done by caller)
	bool IsInGDB();
	void SetMarker();
	static BreakPointInfo *FindFromNumber(int _id, bool use_gdb_id);
	~BreakPointInfo();
};

#endif

