<vector>
	class vector
		size_type size ( ) const;
		template <class InputIterator> void assign ( InputIterator first, InputIterator last );
		void assign ( size_type n, const T& u );
		const_reference at ( size_type n ) const;
		reference at ( size_type n );
		reference back ( );
		const_reference back ( ) const;
		iterator begin ( );
		const_iterator begin ( ) const;
		size_type capacity ( ) const;
		void clear ( );
		bool empty ( ) const;
		iterator end ( );
		const_iterator end ( ) const;
		iterator erase ( iterator position );
		iterator erase ( iterator first, iterator last );
		reference front ( );
		const_reference front ( ) const;
		allocator_type get_allocator ( ) const;
		iterator insert ( iterator position, const T& x );
		void insert ( iterator position, size_type n, const T& x );
		template <class InputIterator> void insert ( iterator position, InputIterator first, InputIterator last );
		size_type max_size ( ) const;
		vector<T,Allocator>& operator= (const vector<T,Allocator>& x);
		reference operator[] ( size_type n );
		const_reference operator[] ( size_type n ) const;
		void pop_back ( );
		void push_back ( const T& x );
		reverse_iterator rbegin ( );
		const_reverse_iterator rbegin ( ) const;
		reverse_iterator rend ( );
		const_reverse_iterator rend ( ) const;
		void reserve ( size_type n );
		void resize ( size_type sz, T c = T() );
		void swap ( vector<T,Allocator>& vec );
		explicit vector ( const Allocator& = Allocator() );
		explicit vector ( size_type n, const T& value= T(), const Allocator& = Allocator() );
		template <class InputIterator> vector ( InputIterator first, InputIterator last, const Allocator& = Allocator() );
		vector ( const vector<T,Allocator>& x );
	
<list>
	class list
		template <class InputIterator> void assign ( InputIterator first, InputIterator last );
		void assign ( size_type n, const T& u );
		reference back ( );
		const_reference back ( ) const;
		iterator begin ( );
		const_iterator begin ( ) const;
		void clear ( );
		bool empty ( ) const;
		iterator end ( );
		const_iterator end ( ) const;
		iterator erase ( iterator position );
		iterator erase ( iterator first, iterator last );
		reference front ( );
		const_reference front ( ) const;
		allocator_type get_allocator ( ) const;
		iterator insert ( iterator position, const T& x );
		void insert ( iterator position, size_type n, const T& x );
		template <class InputIterator> void insert ( iterator position, InputIterator first, InputIterator last );
		explicit list ( const Allocator& = Allocator ( ) );
		explicit list ( size_type n, const T& value = T(), const Allocator& = Allocator() );
		template < class InputIterator > list ( InputIterator first, InputIterator last, const Allocator& = Allocator() );
		list ( const list<T,Allocator>& x );
		size_type max_size ( ) const;
		void merge ( list<T,Allocator>& x );
		template <class Compare> void merge ( list<T,Allocator>& x, Compare comp );
		list<T,Allocator>& operator= ( const list<T,Allocator>& x );
		void pop_back ( );
		void pop_front ( );
		void push_back ( const T& x );
		void push_front ( const T& x );
		reverse_iterator rbegin ( );
		const_reverse_iterator rbegin ( ) const;
		void remove ( const T& value );
		template <class Predicate> void remove_if ( Predicate pred );
		reverse_iterator rend ( );
		const_reverse_iterator rend ( ) const;
		void resize ( size_type sz, T c = T() );
		void reverse ( );
		size_type size ( ) const;
		void sort ( );
		template <class Compare> void sort ( Compare comp );
		void splice ( iterator position, list<T,Allocator>& x );
		void splice ( iterator position, list<T,Allocator>& x, iterator i );
		void splice ( iterator position, list<T,Allocator>& x, iterator first, iterator last );
		void swap ( list<T,Allocator>& lst );
		void unique ( );
		template <class BinaryPredicate> void unique ( BinaryPredicate binary_pred );


	
<map>
	class map
		iterator begin ();
		const_iterator begin () const;
		void clear ( );
		size_type count ( cont key_type& x ) const;
		bool empty ( ) const;
		iterator end ();
		const_iterator end () const;
		pair<iterator,iterator>	equal_range ( const key_type& x );
		pair<const_iterator,const_iterator>	equal_range ( const key_type& x ) const;
		void erase ( iterator position );
		size_type erase ( const key_type& x );
		void erase ( iterator first, iterator last );
		iterator find ( const key_type& x );
		const_iterator find ( const key_type& x ) const;
		allocator_type get_allocator() const;
		pair<iterator,bool> insert ( const value_type& x );
		iterator insert ( iterator position, const value_type& x );
		template <class InputIterator> void insert ( InputIterator first, InputIterator last );
		key_compare key_comp ( ) const;
		iterator lower_bound ( const key_type& x );
		const_iterator lower_bound ( const key_type& x ) const;
		explicit map ( const Compare& comp = Compare(), const Allocator& = Allocator() );
		template <class InputIterator> map ( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator() );
		map ( const map<Key,T,Compare,Allocator>& x );
		size_type max_size () const;
		map<Key,T,Compare,Allocator>& operator= ( const map<Key,T,Compare,Allocator>& x );
		T& operator[] ( const key_type& x );
		reverse_iterator rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator rend();
		const_reverse_iterator rend() const;
		size_type size() const;
		void swap ( map<Key,T,Compare,Allocator>& mp );
		iterator upper_bound ( const key_type& x );
		const_iterator upper_bound ( const key_type& x ) const;
		value_compare value_comp ( ) const;

	class multimap
		iterator begin ( );
		const_iterator begin ( ) const;
		void clear ( );
		size_type count ( cont key_type& x ) const;
		bool empty ( ) const;
		iterator end ( );
		const_iterator end ( ) const;
		pair<iterator,iterator> equal_range ( const key_type& x );
		pair<const_iterator,const_iterator> equal_range ( const key_type& x ) const;
		void erase ( iterator position );
		size_type erase ( const key_type& x );
		void erase ( iterator first, iterator last );
		iterator find ( const key_type& x );
		const_iterator find ( const key_type& x ) const;
		allocator_type get_allocator() const;
		iterator insert ( const value_type& x );
		iterator insert ( iterator position, const value_type& x );
		template <class InputIterator> void insert ( InputIterator first, InputIterator last );
		key_compare key_comp ( ) const;
		iterator lower_bound ( const key_type& x );
		const_iterator lower_bound ( const key_type& x ) const;
		size_type max_size ( ) const;
		multimap<Key,T,Compare,Allocator>& operator= ( const multimap<Key,T,Compare,Allocator>& x );
		reverse_iterator rbegin ( );
		const_reverse_iterator rbegin ( ) const;
		reverse_iterator rend ( );
		const_reverse_iterator rend ( ) const;
		size_type size ( ) const;
		void swap ( map<Key,T,Compare,Allocator>& mmp );
		iterator upper_bound ( const key_type& x );
		const_iterator upper_bound ( const key_type& x ) const;
		value_compare value_comp ( ) const;


<set>
	class set
		iterator begin ();
		const_iterator begin () const;
		void clear ( );
		size_type count ( cont key_type& x ) const;
		bool empty ( ) const;
		iterator end ();
		const_iterator end () const;
		pair<iterator,iterator> equal_range ( const key_type& x ) const;
		void erase ( iterator position );
		size_type erase ( const key_type& x );
		void erase ( iterator first, iterator last );
		iterator find ( const key_type& x ) const;
		allocator_type get_allocator() const;
		pair<iterator,bool> insert ( const value_type& x );
		iterator insert ( iterator position, const value_type& x );
		template <class InputIterator> void insert ( InputIterator first, InputIterator last );
		key_compare key_comp ( ) const;
		iterator lower_bound ( const key_type& x ) const;
		size_type max_size () const;
		set<Key,Compare,Allocator>&	operator= ( const set<Key,Compare,Allocator>& x );
		reverse_iterator rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator rend();
		const_reverse_iterator rend() const;
		explicit set ( const Compare& comp = Compare(), const Allocator& = Allocator() );
		template <class InputIterator> set ( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator() );
		set ( const set<Key,Compare,Allocator>& x );
		size_type size() const;
		void swap ( set<Key,Compare,Allocator>& st );
		iterator upper_bound ( const key_type& x ) const;
		value_compare value_comp ( ) const;

	class multiset
		iterator begin ();
		const_iterator begin () const;
		void clear ( );
		size_type count ( cont key_type& x ) const;
		bool empty ( ) const;
		iterator end ();
		const_iterator end () const;
		pair<iterator,iterator> equal_range ( const key_type& x ) const;
		void erase ( iterator position );
		size_type erase ( const key_type& x );
		void erase ( iterator first, iterator last );
		iterator find ( const key_type& x ) const;
		allocator_type get_allocator() const;
		iterator insert ( const value_type& x );
		iterator insert ( iterator position, const value_type& x );
		template <class InputIterator> void insert ( InputIterator first, InputIterator last );
		key_compare key_comp ( ) const;
		iterator lower_bound ( const key_type& x ) const;
		size_type max_size () const;
		explicit multiset ( const Compare& comp = Compare(), const Allocator& = Allocator() );
		template <class InputIterator> multiset ( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator() );
		multiset ( const multiset<Key,Compare,Allocator>& x );
		multiset<Key,Compare,Allocator>& operator= ( const multiset<Key,Compare,Allocator>& x );
		reverse_iterator rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator rend();
		const_reverse_iterator rend() const;
		size_type size() const;
		void swap ( multiset<Key,Compare,Allocator>& mst );
		iterator upper_bound ( const key_type& x ) const;
		value_compare value_comp ( ) const;

	
<queue>
	class queue
		value_type& back ( );
		const value_type& back ( ) const;
		bool empty ( ) const;
		value_type& front ( );
		const value_type& front ( ) const;
		void pop ( );
		void push ( const T& x );
		explicit queue ( const Container& ctnr = Container() );
		size_type size ( ) const;
		
	class priority_queue
		bool empty ( ) const;
		void pop ( );
		explicit priority_queue ( const Compare& x = Compare(), const Container& y = Container() );
		template <class InputIterator> priority_queue ( InputIterator first, InputIterator last, const Compare& x = Compare(), const Container& y = Container() );
		void push ( const T& x );
		size_type size ( ) const;
		const value_type& top ( ) const;
	
<deque>
	class deque
		template <class InputIterator> void assign ( InputIterator first, InputIterator last );
		void assign ( size_type n, const T& u );
		const_reference at ( size_type n ) const;
		reference at ( size_type n );
		reference back ( );
		const_reference back ( ) const;
		iterator begin ( );
		const_iterator begin ( ) const;
		void clear ( );explicit deque ( const Allocator& = Allocator() );
		explicit deque ( size_type n, const T& value= T(), const Allocator& = Allocator() );
		template <class InputIterator> deque ( InputIterator first, InputIterator last, const Allocator& = Allocator() );
		deque ( const deque<T,Allocator>& x );
		bool empty ( ) const;
		iterator end ( );
		const_iterator end ( ) const;
		iterator erase ( iterator position );
		iterator erase ( iterator first, iterator last );
		reference front ( );
		const_reference front ( ) const;
		allocator_type get_allocator ( ) const;
		iterator insert ( iterator position, const T& x );
		void insert ( iterator position, size_type n, const T& x );
		template <class InputIterator> void insert ( iterator position, InputIterator first, InputIterator last );
		size_type max_size ( ) const;
		deque<T,Allocator>& operator= ( const deque<T,Allocator>& x );
		reference operator[] ( size_type n );
		const_reference operator[] ( size_type n ) const;
		void pop_back ( );
		void pop_front ( );
		void push_back ( const T& x );
		void push_front ( const T& x );
		reverse_iterator rbegin ( );
		const_reverse_iterator rbegin ( ) const;
		reverse_iterator rend ( );
		const_reverse_iterator rend ( ) const;
		void resize ( size_type sz, T c = T() );
		size_type size ( ) const;
		void swap ( list<T,Allocator>& dqe );

<stack>
	class stack
		bool empty ( ) const;
		void pop ( );
		void push ( const T& x );
		size_type size ( ) const;
		explicit stack ( const Container& ctnr = Container() );
		value_type& top ( );
		const value_type& top ( ) const;

<bitset>
	class bitset
		bool any ( ) const;
		bitset ( );
		bitset ( unsigned long val );
		template<class charT, class traits, class Allocator> explicit bitset ( const basic_string<charT,traits,Allocator>& str, typename basic_string<charT,traits,Allocator>::size_type pos = 0, typename basic_string<charT,traits,Allocator>::size_type n = basic_string<charT,traits,Allocator>::npos);
		size_t count ( );
		bitset<N>& flip ( );
		bitset<N>& flip ( size_t pos );
		bool none ( ) const;
		bool operator[] ( size_t pos ) const;
		reference operator[] ( size_t pos );
		bitset<N>& operator&= (const bitset<N>& rhs);
		bitset<N>& operator|= (const bitset<N>& rhs);
		bitset<N>& operator^= (const bitset<N>& rhs);
		bitset<N>& operator<<= (const bitset<N>& rhs);
		bitset<N>& operator>>= (const bitset<N>& rhs);
		bitset<N> operator~() const;
		bitset<N> operator<<(size_t pos) const;
		bitset<N> operator>>(size_t pos) const;
		bool operator== (const bitset<N>& rhs) const;
		bool operator!= (const bitset<N>& rhs) const;
		bitset<N>& reset ( );
		bitset<N>& reset ( size_t pos );
		bitset<N>& set ( );
		bitset<N>& set ( size_t pos, bool val = true );
		bool test ( size_t pos ) const;
		template <class charT, class traits, class Allocator> basic_string<charT,traits,Allocator> to_string() const;
		unsigned long to_ulong ( ) const;
